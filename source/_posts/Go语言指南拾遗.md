---
title: Go语言指南拾遗
author: Bill Zong
tags:
  - golang
categories:
  - Golang
abbrlink: fe86d1b6
date: 2021-04-12 22:32:00
---
## 概要

本篇内容在于对Go的一些基础知识指南部分重点进行汇总，关注一些重要但容易忽略的地方。

如果你已经对`Go`语言掌握地非常自如了，可以直接忽略本文。

## 类型

### array/slice/map

非线程安全。需要并发使用时，用别的库替换它们，或者自己实现一套。

## 操作符

### 整数溢出

编译器**不会检查**整数溢出，它是我们自己的责任。所以，我们也不能确定`x < x + 1`永远为真。

### 浮点数精度

当你指定浮点数精度时，编译器会给你在最大精度位上进行四舍五入，同时也限制了其浮点数操作的范围。

所以多个未定义类型浮点数组合操作，是被允许的；但多个已定义类型、但精度不同的浮点数组合操作，是不允许的，因为精度丢失程度不同。

```
r  = x*y + z // OK
r  = float64(x*y) + z // Fail
```

### 字符串拼接`+`

除非你明确知道，这个操作仅使用有限次数，且拼接长度很短或连续拼接次数少。否则，可能会带来较大的性能瓶颈问题。

### 比较操作符`==`

当且仅当两个表达式可以进行比较时，才能使用它。

Go语言未支持自定义操作符实现，也没有相应的`interface`让你完成该接口。

对比指针数据时，你只能使用`reflect.DeepEqual()`。

### 取地址符`&`

对`nil`取地址，或者其反向操作都会触发`panic`。

```
var x *int = nil
*x   // causes a run-time panic
&*x  // causes a run-time panic
```

### 接收操作符`<-`

会阻塞，会阻塞，会阻塞。

通道关闭时，会生成个0值和状态值，正确的做法应该是检查状态值。

### 类型转换`()`

必须显示地做类型转换，不允许隐式操作。

## 表达式

### 常量表达式

`untyped const`常量可以自由地赋值成同类型变量。

```
const pi = 3.14159265358979
var fpi float = pi
var f64pi float64 = pi
```

`typed const`常量则仅能赋值给同一类型变量

```
const pi float64 = 3.14159265358979
var fpi float = pi // compiler complains
```

### 标签表达式

可考虑在多层判断、深层循环语句中使用`goto/break` + `Labeled 表达式`的方式，直接跳出，简洁明了。

或者使用`continue` + `labeled 表达式`的方式，继续执行外层循环。

### 发送表达式`<-`

给已经关闭的 chan 发送数据，会导致 panic。

给一个 nil 的 chan 发送数据，会永远阻塞，而且非常难排查问题。所以，一定、一定、一定要给 chan 初始化，且赋值为nil后，要检查其相关接收和发送数据的逻辑。

### 赋值

有一些有趣的用法，以及一些注意事项

```
a, b = b, a // exchange

x := []int{1, 2, 3}
i := 0
i, x[i] = 1, 2  // set i = 1, x[0] = 2, 注意赋值的顺序, 避免这种模糊的写法
```

### select表达式

跟`switch`表达式很像，但因为其是对 chan 的操作，会阻塞等待，所以不支持`fallthrough`操作。

### defer表达式

作用域范围内的多个 defer 表达式，是采用栈的数据结构存储，执行顺序是LIFO。

最好避免在 defer 表达式里做太复杂的工作。如果出现这种情况，说明你的方法需要重构了。

## 内建函数

### close

关闭带缓冲的 chan 时，不仅会收到关闭的状态，同时还会将已缓冲但未接收的数据。**——待验证**

### make

使用 make 内建函数，需要注意`make(T, n, m)`中，n值不能大于m，否则在运行时会报 panic。

如果构建时不希望使用 T 的0值（如`Array`类型，你可能只希望初始值是个nil），那么在构建时，应该填入`make(T, 0, m)`或`make(T, 0)`