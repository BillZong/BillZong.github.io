<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Context用法 · 知易行难，一路向前</title><meta name="description" content="Context用法 - Bill Zong"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico?v=2021"><link rel="stylesheet" href="/css/style.css"><link rel="search" type="application/opensearchdescription+xml" href="https://billzong.github.io/atom.xml" title="知易行难，一路向前"><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="知易行难，一路向前" type="application/atom+xml">
<link rel="alternate" href="/rss2.xml" title="知易行难，一路向前" type="application/rss+xml">
</head><body><div class="wrap"><header><h1 class="title">知易行难，一路向前</h1><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link" href="/" target="_self">主页</a></li><li class="nav-list-item"><a class="nav-list-link" href="/archives/" target="_self">归档</a></li><li class="nav-list-item"><a class="nav-list-link" href="https://github.com/billzong" target="_blank">Github主页</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Context用法</h1><div class="post-info">2021-04-12</div><div class="post-content"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在 Go http包的Server中，每一个请求在都有一个对应的 goroutine 去处理。 请求处理函数通常会启动额外的 goroutine 用来访问后端服务，比如数据库和RPC服务。 用来处理一个请求的 goroutine 通常需要访问一些与请求特定的数据，比如终端用户的身份认证信息、验证相关的token、请求的截止时间。 当一个请求被取消或超时时，所有用来处理该请求的 goroutine 都应该迅速退出，然后系统才能释放这些 goroutine 占用的资源。 那么该如何优雅地同时关闭多个goroutine呢？ 这个时候就轮到context包上场了。</p>
<h2 id="Context的核心数据结构"><a href="#Context的核心数据结构" class="headerlink" title="Context的核心数据结构"></a>Context的核心数据结构</h2><p>type Context interface 是 package context的核心数据结构：</p>
<ol>
<li><p>Done 方法返回一个 channel，这个 channel 对于以 Context 方式运行的函数而言，是一个取消信号。 当这个 channel 关闭时，上面提到的这些函数应该终止手头的工作并立即返回。 之后，Err 方法会返回一个错误，告知为什么 Context 被取消。</p>
</li>
<li><p>Context 对象是线程安全的，你可以把一个 Context 对象传递给任意个数的 gorotuine，对它执行取消操作时，所有 goroutine 都会接收到取消信号。</p>
</li>
<li><p>Deadline() 方法允许函数确定它们是否应该开始工作。 如果剩下的时间太少，也许这些函数就不值得启动。在代码中，我们也可以使用 Deadline 对象为 I/O 操作设置截止时间。</p>
</li>
<li><p>Value 方法允许 Context 对象携带request作用域的数据，该数据必须是线程安全的。</p>
</li>
<li><p>一个 Context 不能拥有 Cancel() 方法，同时我们也只能使用 Done channel 来接收数据。 原因是：接收取消信号的函数和发送取消信号的函数通常不是一个。 一个典型的场景是：父操作为子操作操作启动 goroutine，子操作也就不能取消父操作。 作为一个折中，WithCancel() 函数提供了一种取消新的 Context 的方法。</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Context carries a deadline, a cancelation signal, and other values across</span></span><br><span class="line"><span class="comment">// API boundaries.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Context's methods may be called by multiple goroutines simultaneously.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Deadline returns the time when work done on behalf of this context</span></span><br><span class="line">	<span class="comment">// should be canceled. Deadline returns ok==false when no deadline is</span></span><br><span class="line">	<span class="comment">// set. Successive calls to Deadline return the same results.</span></span><br><span class="line">	Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Done returns a channel that's closed when work done on behalf of this</span></span><br><span class="line">	<span class="comment">// context should be canceled. Done may return nil if this context can</span></span><br><span class="line">	<span class="comment">// never be canceled. Successive calls to Done return the same value.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// WithCancel arranges for Done to be closed when cancel is called;</span></span><br><span class="line">	<span class="comment">// WithDeadline arranges for Done to be closed when the deadline</span></span><br><span class="line">	<span class="comment">// expires; WithTimeout arranges for Done to be closed when the timeout</span></span><br><span class="line">	<span class="comment">// elapses.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Done is provided for use in select statements:</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//  // Stream generates values with DoSomething and sends them to out</span></span><br><span class="line">	<span class="comment">//  // until DoSomething returns an error or ctx.Done is closed.</span></span><br><span class="line">	<span class="comment">//  func Stream(ctx context.Context, out chan&lt;- Value) error &#123;</span></span><br><span class="line">	<span class="comment">//  	for &#123;</span></span><br><span class="line">	<span class="comment">//  		v, err := DoSomething(ctx)</span></span><br><span class="line">	<span class="comment">//  		if err != nil &#123;</span></span><br><span class="line">	<span class="comment">//  			return err</span></span><br><span class="line">	<span class="comment">//  		&#125;</span></span><br><span class="line">	<span class="comment">//  		select &#123;</span></span><br><span class="line">	<span class="comment">//  		case &lt;-ctx.Done():</span></span><br><span class="line">	<span class="comment">//  			return ctx.Err()</span></span><br><span class="line">	<span class="comment">//  		case out &lt;- v:</span></span><br><span class="line">	<span class="comment">//  		&#125;</span></span><br><span class="line">	<span class="comment">//  	&#125;</span></span><br><span class="line">	<span class="comment">//  &#125;</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// See http://blog.golang.org/pipelines for more examples of how to use</span></span><br><span class="line">	<span class="comment">// a Done channel for cancelation.</span></span><br><span class="line">	Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Err returns a non-nil error value after Done is closed. Err returns</span></span><br><span class="line">	<span class="comment">// Canceled if the context was canceled or DeadlineExceeded if the</span></span><br><span class="line">	<span class="comment">// context's deadline passed. No other values for Err are defined.</span></span><br><span class="line">	<span class="comment">// After Done is closed, successive calls to Err return the same value.</span></span><br><span class="line">	Err() error</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Value returns the value associated with this context for key, or nil</span></span><br><span class="line">	<span class="comment">// if no value is associated with key. Successive calls to Value with</span></span><br><span class="line">	<span class="comment">// the same key returns the same result.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Use context values only for request-scoped data that transits</span></span><br><span class="line">	<span class="comment">// processes and API boundaries, not for passing optional parameters to</span></span><br><span class="line">	<span class="comment">// functions.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// A key identifies a specific value in a Context. Functions that wish</span></span><br><span class="line">	<span class="comment">// to store values in Context typically allocate a key in a global</span></span><br><span class="line">	<span class="comment">// variable then use that key as the argument to context.WithValue and</span></span><br><span class="line">	<span class="comment">// Context.Value. A key can be any type that supports equality;</span></span><br><span class="line">	<span class="comment">// packages should define keys as an unexported type to avoid</span></span><br><span class="line">	<span class="comment">// collisions.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Packages that define a Context key should provide type-safe accessors</span></span><br><span class="line">	<span class="comment">// for the values stores using that key:</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 	// Package user defines a User type that's stored in Contexts.</span></span><br><span class="line">	<span class="comment">// 	package user</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 	import "golang.org/x/net/context"</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 	// User is the type of value stored in the Contexts.</span></span><br><span class="line">	<span class="comment">// 	type User struct &#123;...&#125;</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 	// key is an unexported type for keys defined in this package.</span></span><br><span class="line">	<span class="comment">// 	// This prevents collisions with keys defined in other packages.</span></span><br><span class="line">	<span class="comment">// 	type key int</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 	// userKey is the key for user.User values in Contexts. It is</span></span><br><span class="line">	<span class="comment">// 	// unexported; clients use user.NewContext and user.FromContext</span></span><br><span class="line">	<span class="comment">// 	// instead of using this key directly.</span></span><br><span class="line">	<span class="comment">// 	var userKey key = 0</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 	// NewContext returns a new Context that carries value u.</span></span><br><span class="line">	<span class="comment">// 	func NewContext(ctx context.Context, u *User) context.Context &#123;</span></span><br><span class="line">	<span class="comment">// 		return context.WithValue(ctx, userKey, u)</span></span><br><span class="line">	<span class="comment">// 	&#125;</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 	// FromContext returns the User value stored in ctx, if any.</span></span><br><span class="line">	<span class="comment">// 	func FromContext(ctx context.Context) (*User, bool) &#123;</span></span><br><span class="line">	<span class="comment">// 		u, ok := ctx.Value(userKey).(*User)</span></span><br><span class="line">	<span class="comment">// 		return u, ok</span></span><br><span class="line">	<span class="comment">// 	&#125;</span></span><br><span class="line">	Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建根context"><a href="#创建根context" class="headerlink" title="创建根context"></a>创建根context</h2><p>context 包提供了一些函数，协助用户从现有的 Context 对象创建新的 Context 对象。 这些 Context 对象形成一棵树：当一个 Context 对象被取消时，继承自它的所有 Context 都会被取消。</p>
<p>Background()是所有 Context 对象树的根，它不能被取消。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span> <span class="title">Context</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> background</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建子context"><a href="#创建子context" class="headerlink" title="创建子context"></a>创建子context</h2><p>WithCancel 和 WithTimeout 函数会返回继承的 Context 对象，这些对象可以比它们的父 Context 更早地取消。 当请求处理函数返回时，与该请求关联的 Context 会被取消。</p>
<ul>
<li>当使用多个副本发送请求时，可以使用 WithCancel 取消多余的请求。</li>
<li>WithTimeout 在设置对后端服务器请求截止时间时非常有用。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span> <span class="params">(ctx Context, cancel CancelFunc)</span></span> &#123;</span><br><span class="line">	ctx, f := context.WithCancel(parent)</span><br><span class="line">	<span class="keyword">return</span> ctx, CancelFunc(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span> <span class="params">(Context, CancelFunc)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> WithDeadline(parent, time.Now().Add(timeout))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="WithTimeout例子"><a href="#WithTimeout例子" class="headerlink" title="WithTimeout例子"></a>WithTimeout例子</h2><p>以下是官方提供的例子，子context ctx会在30Second后被关闭，从而触发了<code>ctx.Done()</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(), <span class="number">30</span>*time.Second)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(<span class="number">2</span> * time.Minute):</span><br><span class="line">		fmt.Println(<span class="string">"overslept"</span>)</span><br><span class="line">	<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">		fmt.Println(ctx.Err()) <span class="comment">// prints "context deadline exceeded"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里输出结果是</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context deadline exceeded</span><br></pre></td></tr></table></figure>

<h2 id="context的使用规范"><a href="#context的使用规范" class="headerlink" title="context的使用规范"></a>context的使用规范</h2><ol>
<li>context包里的方法是线程安全的，可以被多个线程使用</li>
<li>就算是被多个不同的goroutine使用，context也是安全的</li>
<li>把context作为第一个参数，并且一般都把变量命名为ctx</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://segmentfault.com/a/1190000006744213" target="_blank" rel="noopener">Go语言并发模型：使用 context</a></p>
<p><a href="http://www.nljb.net/default/Golang之Context的使用/" target="_blank" rel="noopener">Golang之Context的使用</a></p>
<p><a href="https://studygolang.com/articles/9485" target="_blank" rel="noopener">Golang之Context</a></p>
<p><a href="http://blog.csdn.net/xiaohu50/article/details/49100433" target="_blank" rel="noopener">源码解读</a></p>
</div></article></div></main><footer><div class="paginator"><a class="prev" href="/post/89751058.html">上一篇</a><a class="next" href="/post/107a8b74.html">下一篇</a></div><div class="copyright"><p>© 2021 PEACE & LOVE</p><p>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>, <a href="https://github.com/jeremyfan/hexo-theme-still" target="_blank">theme</a> by <a href="https://github.com/jeremyfan" target="_blank">Bill Zong</a>.</p></div></footer></div></body></html>