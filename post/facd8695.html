<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> GraphQL API服务go语言版本的介绍 · 知易行难，一路向前</title><meta name="description" content="GraphQL API服务go语言版本的介绍 - Bill Zong"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico?v=2021"><link rel="stylesheet" href="/css/style.css"><link rel="search" type="application/opensearchdescription+xml" href="https://billzong.github.io/atom.xml" title="知易行难，一路向前"><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="知易行难，一路向前" type="application/atom+xml">
<link rel="alternate" href="/rss2.xml" title="知易行难，一路向前" type="application/rss+xml">
</head><body><div class="wrap"><header><h1 class="title">知易行难，一路向前</h1><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link" href="/" target="_self">主页</a></li><li class="nav-list-item"><a class="nav-list-link" href="/archives/" target="_self">归档</a></li><li class="nav-list-item"><a class="nav-list-link" href="https://github.com/billzong" target="_blank">Github主页</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">GraphQL API服务go语言版本的介绍</h1><div class="post-info">2021-04-08</div><div class="post-content"><h2 id="GraphQL-API-是什么"><a href="#GraphQL-API-是什么" class="headerlink" title="GraphQL API 是什么"></a>GraphQL API 是什么</h2><p>GraphQL 是一个用于 API 的查询语言，是一个使用基于类型系统来执行查询的服务端运行时（类型系统由你的数据定义）。GraphQL 并没有和任何特定数据库或者存储引擎绑定，而是依靠你现有的代码和数据支撑。</p>
<p>优势：</p>
<ul>
<li>不多不少，只请求你所要的数据</li>
<li>只用一个请求，获取多个资源</li>
<li>类型系统，描述所有的可能</li>
</ul>
<p>有需要的童鞋可以了解一下<a href="http://spec.graphql.cn/" target="_blank" rel="noopener">详细的语法规范</a>。</p>
<p>关于 GraphQL 的基本介绍和为什么选择 GraphQL，官方文档有相应的介绍，有兴趣的童鞋可以去看看。这里就不一一赘述了。</p>
<h2 id="如何引入"><a href="#如何引入" class="headerlink" title="如何引入"></a>如何引入</h2><p>引入 GraphQL API 在移动端后台架构是一个节约流量、提升性能、提高灵活性的不错选择。但怎么在已有的代码、框架中，引入这种编程模型接口，值得我们思考一番。</p>
<p>幸运的是，开源社区已经为我们做了不少工作。GraphQL有众多语言版本的服务端库实现，当然也包括 go 语言。</p>
<p>其中比较知名也比较成熟的库<a href="https://github.com/graphql-go/graphql" target="_blank" rel="noopener">graphql</a>，直接就可以集成。</p>
<p>当然，部分开源网络框架，如<a href="https://github.com/kataras/iris" target="_blank" rel="noopener">iris</a>，是通过中间件的方式进行注册使用的。<br>对于这种网络框架，我们需要将这些 API 库解析器作为中间件的方式连接上去，再绑定到接口上，就能节约大量的集成工作。</p>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 这里定义了 hello 字段和相应的返回结果</span></span><br><span class="line">	fields := graphql.Fields&#123;</span><br><span class="line">		<span class="string">"hello"</span>: &amp;graphql.Field&#123;</span><br><span class="line">			Type: graphql.String,</span><br><span class="line">			Resolve: <span class="function"><span class="keyword">func</span><span class="params">(p graphql.ResolveParams)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="string">"world"</span>, <span class="literal">nil</span></span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 创建schema</span></span><br><span class="line">	rootQuery := graphql.ObjectConfig&#123;Name: <span class="string">"RootQuery"</span>, Fields: fields&#125;</span><br><span class="line">	schemaConfig := graphql.SchemaConfig&#123;Query: graphql.NewObject(rootQuery)&#125;</span><br><span class="line">	schema, _ := graphql.NewSchema(schemaConfig)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 模拟一个 GraphQL query</span></span><br><span class="line">	query := <span class="string">`</span></span><br><span class="line"><span class="string">		&#123;</span></span><br><span class="line"><span class="string">			hello</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">	`</span></span><br><span class="line">	<span class="comment">// 解析参数</span></span><br><span class="line">	params := graphql.Params&#123;Schema: schema, RequestString: query&#125;</span><br><span class="line">	r := graphql.Do(params) <span class="comment">// 执行，这里忽略了错误处理</span></span><br><span class="line">	rJSON, _ := json.Marshal(r) <span class="comment">// rJSON = &#123;“data”:&#123;“hello”:”world”&#125;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>考虑到支持原有 jSON 对象查询的方式，可以在目前已有的接口上增加一个顶层路径<code>/graphql</code>，对于该路径下的操作，支持 GraphQL API 操作，也是个不错的选择。示例如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">"/graphql"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		result := executeQuery(r.URL.Query().Get(<span class="string">"query"</span>), schema) <span class="comment">// 使用已创建好的域进行查询解析</span></span><br><span class="line">		json.NewEncoder(w).Encode(result)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">// Serve static files</span></span><br><span class="line">	fs := http.FileServer(http.Dir(<span class="string">"static"</span>))</span><br><span class="line">	http.Handle(<span class="string">"/"</span>, fs)</span><br><span class="line"></span><br><span class="line">	http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="重点、难点"><a href="#重点、难点" class="headerlink" title="重点、难点"></a>重点、难点</h2><ul>
<li>解耦业务逻辑</li>
<li>分解域</li>
</ul>
<p>当集成不成问题后，怎么在原来业务代码里将逻辑解耦，重新组装成域，并提供相应的查询、更新业务支持，就成了我们接下去要解决的问题。</p>
<p>预知后事如何，且听下回分解。</p>
</div></article></div></main><footer><div class="paginator"><a class="prev" href="/post/d3239b62.html">上一篇</a><a class="next" href="/post/beb9dd3.html">下一篇</a></div><div class="copyright"><p>© 2021 PEACE & LOVE</p><p>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>, <a href="https://github.com/jeremyfan/hexo-theme-still" target="_blank">theme</a> by <a href="https://github.com/jeremyfan" target="_blank">Bill Zong</a>.</p></div></footer></div></body></html>